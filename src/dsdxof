#! /usr/bin/octave -q

%% This file is part of DSD
%%
%% DSD
%% A GNU-Octave set of scripts for calculating
%% digital loudspeaker crossovers and room correction filters
%% Copyright (C) 2012-2019 Roberto Ripio
%%
%% DSD is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%%
%% DSD is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%%
%% You should have received a copy of the GNU General Public License
%% along with DSD.  If not, see <https://www.gnu.org/licenses/>.



%% prepare


% avoid checking timestamps of DSD m files for better performance
ignore_function_time_stamp ("all")

% say hello
disp("\n\
dsdxof\n\
Loudspeaker crossover and equalizer design\n\
Part of DSD (C) 2012-2019 Roberto Ripio\
\n");

% parse command line
p = inputParser;
% mandatory script filename as first parameter
p.addRequired("script", @ischar);
% optional fs as "fs <integer_number>"
p.addParameter("fs",0,@(x) mod(str2double(x),1) == 0)
% optional filter class as "class <lp|mp>"
p.addParameter("class","none",@(x) any (strcmp (x, {"none","lp", "mp"})));
% 'nopause' switch: do not show graphics on-screen
p.addSwitch("nopause");
try
    p.parse(argv(){:});
catch
    % lasterror()
    disp( "Error:");
    disp(["Incorrect command line parameters. " ...
             "Cannot continue: exiting...\n"]);
    return         
end_try_catch

% check for default config file and sources it
configDefaults=[mfilename("fullpath") ".ini"];
if exist(configDefaults, "file")
    source(configDefaults); % Reads default config
else
    disp( "Warning:");
    disp(["file \"" configDefaults "\" not found."]);
    disp( "Running without defaults.\n");
end

% check for design script file and sources it
filename = [p.Results.script '.xof'];
if exist(filename, "file")
    source(filename); % Reads project config
else
    disp("Error:");
    disp(["Script file \"" filename "\" not found. " ...
             "Cannot continue: exiting...\n"]);
    quit();
end

% check for fs as command line parameter
if p.Results.fs != 0
    GSFs=str2num(p.Results.fs);
end
strGSFs = num2str(GSFs);

% check for filter class as command line parameter
if ! strcmp(p.Results.class, "none")
    CFClass = p.Results.class;
end

% check for 'nopause' switch
if p.Results.nopause
    PSShow=false;
end

% Set file output folder and prefix
% filename suffix taken from frd file
[dummyFSOutDir , FSOutSuffix] = fileparts(FSInputFile);
% directory path taken from script file
[FSOutDir , dummyFSOutSuffix] = fileparts(filename);
if length(FSOutDir)==0
    FSOutDir = ".";
end
FSOutDir = [FSOutDir "/" strGSFs "/"];
mkdir(FSOutDir);

FSOutName = ["xo-" CFClass "-" FSOutSuffix];


%%  Calculate


% Some variable prefixes:
% TFR Target Frequency Response
% IFR Inverted target Frequency Response
% LS  LoudSpeaker frequency response

% begin chronometer for calculation time asessment
t1=time;

% We make equal length speaker correction filters and crossover filters of
% final length 'm'. They will be trimmed and windowed to half the final length
% and later convolved and padded to get the composed filter of length 'm'.
%
% Real frequency vectors will then have 'm/2' length
% at any phase of calculations

% Final filter length and corresponding real F lenght
m=2^GSLExp; mrf=m/2+1;
% Speaker EQ and XO length
m_ls=m/2;
% Calculation filter length and corresponding real F lenght
m_calc=2^GSLExpCalc; mrf_calc=m_calc/2+1;

% frequency jump between bins
% (sampling frequency divided by filter length)
fl=GSFs/m;
fl_calc=GSFs/m_calc;
% max freq
fh_calc=mrf_calc-1*fl_calc;

% column vector of linearly spaced real frequencies
F      = (0:mrf-1)'*fl;
F_calc = (0:mrf_calc-1)'*fl_calc;


% Some information on screen

FSOutName
GSFs
GSLExp
m

% LSdB, magnitude response from .frd file
[LSF_in, LSdB_in] = loadfrd (FSInputFile);
LSdB_pp = interp1(LSF_in, LSdB_in, 'spline','pp');
LSdB = ppval(LSdB_pp, F);
LSdB_calc = ppval(LSdB_pp, F_calc);


% Calculates transition limits
if CFLowF(1)==0
    TWLowF2=TWLimitLowF2;
else
    TWLowF2=CFLowF(1)/(2^TWFlatInterval);
    if TWLowF2<TWLimitLowF2 TWLowF2=TWLimitLowF2; end;
end
TWLowF1=TWLowF2/(2^TWTransitionInterval);
if TWLowF1<TWLimitLowF1 TWLowF1=TWLimitLowF1; end;
TWLowK2=round(TWLowF2/fl_calc)+1;
TWLowK1=round(TWLowF1/fl_calc)+1;
if TWLowK1<2 TWLowK1=2; end;
if TWLowK2<3 TWLowK2=3; end;

if CFHighF==0
    TWHighF1=TWLimitHighF1;
else
    TWHighF1=CFHighF*(2^TWFlatInterval);
    if TWHighF1>TWLimitHighF1 TWHighF1=TWLimitHighF1; end;
end
TWHighF2=TWHighF1*(2^TWTransitionInterval);
if TWHighF2>TWLimitHighF2 TWHighF2=TWLimitHighF2; end;
TWHighK1=round(TWHighF1/fl_calc)+1;
TWHighK2=round(TWHighF2/fl_calc)+1;
if TWHighK2>mrf_calc TWHighK2=mrf_calc; end;
if TWHighK1>mrf_calc-1 TWHighK1=mrf_calc-1; end;


% TFR Target Frequency Response
k=(1:m_calc);
logweight=[0,log((k+.5)./(k-.5))]';
logmeanLow=sum(LSdB_calc(TWLowK1:TWLowK2).*logweight(TWLowK1:TWLowK2))/ ...
                                    sum(logweight(TWLowK1:TWLowK2));
logmeanHigh=sum(LSdB_calc(TWHighK1:TWHighK2).*logweight(TWHighK1:TWHighK2))/ ...
                                    sum(logweight(TWHighK1:TWHighK2));
TWLowdB= ones(mrf_calc,1)*logmeanLow;
TWHighdB=ones(mrf_calc,1)*logmeanHigh;

TFRdB=frjoin(TWLowdB,LSdB_calc,TWLowK1,TWLowK2);
TFRdB=frjoin(TFRdB,TWHighdB,TWHighK1,TWHighK2);
% dB values untouched, for plotting
TFRMag=dB2mag(TFRdB);

% IFR Inverted target Frequency Response
IFRMag=1./TFRMag; % Response inversion
% Normalize response (attenuation only)
% Calculates Band Limits
BLLowF = CFLowF(1);
if BLLowF==0 BLLowF=TWLimitLowF2; end
BLLowK=ceil(BLLowF/fl_calc)+1;

BLHighF = CFHighF;
if BLHighF==0 BLHighF=TWLimitHighF1; end
BLHighK=floor(BLHighF/fl_calc)+1;
if BLHighF>fh_calc BLHighF=fh_calc; end;

% Interpolate target at band limits
IFRMag_lims=interp1(F_calc, IFRMag, [BLLowF;BLHighF]);

normfactor=max([IFRMag(BLLowK:BLHighK);IFRMag_lims]);
% Normalized equalization filter (attenuation only)
IFRImp = ifft(minphsp(wholespmp(IFRMag)))/normfactor;

% Trims to EQ length and windows EQ correction impulse
IFRImp=semiblackman(m_ls).*IFRImp(1:m_ls);


% Crossover filter

switch(CFClass)
    case "lp"
        if CFLowAsMP && strcmp (CFLowType{1}, "B") && (CFLowF(1) > 0)
            CFLowImp = crossButterworthLP(GSFs,m_ls/2,CFLowOrder(1)...
                                                    ,CFLowF(1),0,0);
            CFHighImp = crossLinear(GSFs,m_ls/2,CFLenghthFactor,0,CFHighF);
            % both already windowed
            CFImp=postpad(fftconv(CFLowImp,CFHighImp), m_ls);
        elseif (CFHighF > 0 || CFLowF(1) > 0) % Crossover filter
            CFImp = crossLinear(GSFs,m_ls,CFLenghthFactor,CFLowF(1),CFHighF);
        else
            CFImp=delta(m_ls);


            CFClass='mp'; % ???????????????????????????????


        end
    case "mp"
        CFLowImp=delta(m_calc);
        for i = 1:length(CFLowF)
            % Highpass
            if CFLowF(i) > 0
                switch(CFLowType{i})
                    case "B"
                        CFLowImpTemp =  crossButterworth(
                            GSFs,m_calc,CFLowOrder(i),CFLowF(i),0,0);
                    case "LR"
                        CFLowImpTemp = crossLinkwitzRiley(
                            GSFs,m_calc,CFLowOrder(i),CFLowF(i),0,0);
                end
            else
                CFLowImpTemp=delta(m_calc);
            end
            CFLowImp=fftconv(CFLowImp,CFLowImpTemp);
        end
        % Lowpass
        if CFHighF > 0
            switch(CFHighType)
                case "B"
                    CFHighImp = crossButterworth(
                        GSFs,m_calc,0,0,CFHighOrder,CFHighF);
                case "LR"
                    CFHighImp = crossLinkwitzRiley(
                        GSFs,m_calc,0,0,CFHighOrder,CFHighF);
            end
        else
            CFHighImp=delta(m_calc);
        end
        CFImp=fftconv(CFLowImp,CFHighImp);
        % Trims and windows crossover filter
        CFImp=semiblackman(m_ls).*CFImp(1:m_ls);
end

%Convolves with loudspeaker correction
CFEqImp=postpad(fftconv(IFRImp,CFImp),m);

% Prepares final response
% XO magnitude
CFEqdB=mag2dB(abs(semisp(fft(CFEqImp))));
OUTdB=CFEqdB+LSdB;

% Saves complete filter
if FSOutPcmFilter
    savepcm(CFEqImp, [FSOutDir FSOutName '.pcm']);
end
if FSOutWavFilter
    audiowrite([FSOutDir FSOutName '.wav'],
            CFEqImp, GSFs, 'BitsPerSample', FSOutWavDepth);
end

% some indications
normfactor_dB = mag2dB(normfactor)
t2=time;
disp (["\n" "Calculated in ", num2str(t2-t1), " s" "\n"]);



%% plot


figure(1,'visible','off');
hold on;
%gcf();

% plots original response
semilogx(
    F(2:end),LSdB(2:end) + normfactor_dB,strcat("1",";",'Original',";"));
% plots target response
semilogx(
    F_calc(2:end),TFRdB(2:end) + normfactor_dB,strcat("2",";",'Model',";"));
% plots CF response
semilogx(
    F(2:end),CFEqdB(2:end),strcat("4",";",'Filter',";"));
% plots final response
semilogx(
    F(2:end),OUTdB(2:end) + normfactor_dB,strcat("3",";",'Result',";"));

legend("boxoff")
legend("location", "north", "orientation", "horizontal");

% define plot axis
audioaxe(PSVTop,PSVRange,PSVStep,PSFLow,PSFHigh,FSOutName);

% saves plot image
if PSOutRaster
    print ([FSOutDir, FSOutName, ".", PSOutRasterExt]);
end
if PSOutVector
    print ([FSOutDir, FSOutName, ".", PSOutVectorExt]);
end

hold off;



%% log


% save normalization factor
normfactor_dB_str=num2str(normfactor_dB);
normfile = [FSOutDir FSNormFile];
% unlink(normfile); % only once for each fs
fid=fopen(normfile, "a+t");
fputs(fid,[FSOutName, "\t\t"]);
fputs(fid,[normfactor_dB_str, "\n\n"]);
fclose(fid);

% scale the graphic and pause to examine it
if PSShow
%    figure(1,'units','normalized','position',[0,1,0.5,0.5])
    figure(1,'units','normalized','position',[PSPos,PSSize])
    disp ("Press any key...\n");
    pause()
end

%% finis coronat opus
