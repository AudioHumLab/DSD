#! /usr/bin/octave -q

%% This file is part of DSD
%%
%% DSD
%% A GNU-Octave set of scripts for calculating
%% digital loudspeaker crossovers and room correction filters
%% Copyright (C) 2012-2019 Roberto Ripio
%%
%% DSD is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% (at your option) any later version.
%%
%% DSD is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%% GNU General Public License for more details.
%%
%% You should have received a copy of the GNU General Public License
%% along with DSD.  If not, see <https://www.gnu.org/licenses/>.



%% prepare


% avoid checking timestamps of DSD m files for better performance
ignore_function_time_stamp ("all")

% say hello
disp("\n\
dsdxof\n\
Loudspeaker crossover and equalizer design\n\
Part of DSD (C) 2012-2019 Roberto Ripio\
\n");

% parse command line
p = inputParser;
% mandatory script filename as first parameter
p.addRequired("script", @ischar);
% optional fs as "fs <integer_number>"
p.addParameter("fs",0,@(x) mod(str2double(x),1) == 0)
% optional filter class as "class <lp|mp>"
p.addParameter("class","none",@(x) any (strcmp (x, {"none","lp", "mp"})));
try
    p.parse(argv(){:});
catch
    % lasterror()
    disp( "Error:");
    disp(["Incorrect command line parameters. " ...
             "Cannot continue: exiting...\n"]);
    quit();            
end_try_catch

% begin chronometer for calculation time asessment
t1=time;

% check for default config file and sources it
configDefaults=[mfilename("fullpath") ".ini"];
if exist(configDefaults, "file")
    source(configDefaults); % Reads default config
else
    disp( "Warning:");
    disp(["file \"" configDefaults "\" not found."]);
    disp( "Running without defaults.\n");
end

% check for design script file and sources it
filename = [p.Results.script '.xof'];
if exist(filename, "file")
    source(filename); % Reads project config
else
    disp("Error:");
    disp(["Script file \"" filename "\" not found. " ...
             "Cannot continue: exiting...\n"]);
    quit();
end

% check for fs as command line parameter
if p.Results.fs != 0
    GSFs=str2num(p.Results.fs);
end
strGSFs = num2str(GSFs);

% check for flter class as command line parameter
if p.Results.class != "none"
    CFClass = p.Results.class;
end

% Set file output folder and prefix
% filename suffix taken from frd file
[dummyFSOutDir , FSOutSuffix] = fileparts(FSInputFile);
% directory path taken from script file
[FSOutDir , dummyFSOutSuffix] = fileparts(filename);
if length(FSOutDir)==0
    FSOutDir = ".";
end
FSOutDir = [FSOutDir "/" strGSFs "/"];
mkdir(FSOutDir);

FSOutName = ["xo-" CFClass "-" FSOutSuffix];

% Some advertizing on screen
GSFs
FSOutName
disp ("\n");
% MS Message Settings
MSOk = "OK\n"; % End of routine confirmation



%%  Calculate


c0=343; %speed of sound
pi2=2*pi;

% m, fft computation length
% We make equal length speaker correction filters and linear crossovers
% (half of final length)
m=2^GSLExp; m2=m/2; % Final filter length
m_ls=m/2; m2_ls=m2/2; % Speaker correction length

%%% Loudspeaker frequency response inversion %%%
% Reads magnitude response from .frd file
LSdB = frdinterp(FSInputFile,m_ls,GSFs);

ml_ls=GSFs/m_ls; % low freq, freq jump
mh_ls=m2_ls*ml_ls; % max freq

% Calculates transition limits
if CFLowF(1)==0
    TWLowF2=TWLimitLowF2;
else
    TWLowF2=CFLowF(1)/(2^TWFlatInterval);
    if TWLowF2<TWLimitLowF2 TWLowF2=TWLimitLowF2; end;
end
TWLowF1=TWLowF2/(2^TWTransitionInterval);
if TWLowF1<TWLimitLowF1 TWLowF1=TWLimitLowF1; end;
TWLowK2=round(TWLowF2/ml_ls)+1;
TWLowK1=round(TWLowF1/ml_ls)+1;
if TWLowK1<2 TWLowK1=2; end;
if TWLowK2<3 TWLowK2=3; end;

if CFHighF==0
    TWHighF1=TWLimitHighF1;
else
    TWHighF1=CFHighF*(2^TWFlatInterval);
    if TWHighF1>TWLimitHighF1 TWHighF1=TWLimitHighF1; end;
end
TWHighF2=TWHighF1*(2^TWTransitionInterval);
if TWHighF2>TWLimitHighF2 TWHighF2=TWLimitHighF2; end;
TWHighK1=round(TWHighF1/ml_ls)+1;
TWHighK2=round(TWHighF2/ml_ls)+1;
if TWHighK2>m2_ls TWHighK2=m2_ls; end;
if TWHighK1>m2_ls-1 TWHighK1=m2_ls-1; end;

% TFR Target Frequency Response
k=(1:m_ls);
logweight=[0,log((k+.5)./(k-.5))]';
logmeanLow=sum(LSdB(TWLowK1:TWLowK2).*logweight(TWLowK1:TWLowK2))/ ...
                                    sum(logweight(TWLowK1:TWLowK2));
logmeanHigh=sum(LSdB(TWHighK1:TWHighK2).*logweight(TWHighK1:TWHighK2))/ ...
                                    sum(logweight(TWHighK1:TWHighK2));
TWLowdB= ones(m2_ls+1,1)*logmeanLow;
TWHighdB=ones(m2_ls+1,1)*logmeanHigh;

TFRdB=frjoin(TWLowdB,LSdB,TWLowK1,TWLowK2);
TFRdB=frjoin(TFRdB,TWHighdB,TWHighK1,TWHighK2);
% dB values untouched, for plotting
TFRMag=dB2mag(TFRdB);
IFRMag=1./TFRMag; % Response inversion
% Normalize response (attenuation only)
% Calculates band limits
BLLowF = CFLowF(1);
if BLLowF==0 BLLowF=TWLimitLowF2; end
BLLowK=round(BLLowF/ml_ls)+1;
BLHighF = CFHighF;
if BLHighF==0 BLHighF=TWLimitHighF1; end
% BLHighK=round(CFHighF/ml_ls)+1;
BLHighK=round(BLHighF/ml_ls)+1;
if BLHighF>mh_ls BLHighF=mh_ls; end;

normfactor=max(IFRMag(BLLowK:BLHighK));
% Normalized equalization filter (attenuation only)
IFRImp = ifft(minphsp(wholespmp(IFRMag)))/normfactor;
IFRImp=semiblackman(m_ls).*IFRImp(1:m_ls);


switch(CFClass)
    case "lp"
        if CFLowAsMP & strcmp (CFLowType{1}, "B") & (CFLowF(1) > 0)
            CFLowImp = crossButterworthLP(GSFs,m_ls/2,CFLowOrder(1)...
                                                    ,CFLowF(1),0,0);
            CFHighImp = crossLinear(GSFs,m_ls/2,CFLenghthFactor,0,CFHighF);
            % both already windowed
            CFImp=postpad(fftconv(CFLowImp,CFHighImp), m_ls);
        elseif (CFHighF > 0 | CFLowF(1) > 0) % Crossover filter
            CFImp = crossLinear(GSFs,m_ls,CFLenghthFactor,CFLowF(1),CFHighF);
        else
            CFImp=delta(m_ls);
            CFClass='mp'; % ???
        end
    case "mp"
        CFLowImp=delta(m_ls);
        for i = 1:length(CFLowF)
            % Highpass
            if CFLowF(i) > 0
                switch(CFLowType{i})
                    case "B"
                        CFLowImpTemp = crossButterworth(GSFs,m_ls,CFLowOrder(i),CFLowF(i),0,0);
                    case "LR"
                        CFLowImpTemp = crossLinkwitzRiley(GSFs,m_ls,CFLowOrder(i),CFLowF(i),0,0);
                end
            else
                CFLowImpTemp=delta(m_ls);
            end
            CFLowImp=fftconv(CFLowImp,CFLowImpTemp);
        end
        % Lowpass
        if CFHighF > 0
            switch(CFHighType)
                case "B"
                    CFHighImp = crossButterworth(GSFs,m_ls,0,0,CFHighOrder,CFHighF);
                case "LR"
                    CFHighImp = crossLinkwitzRiley(GSFs,m_ls,0,0,CFHighOrder,CFHighF);
            end
        else
            CFHighImp=delta(m_ls);
        end
        CFImp=fftconv(CFLowImp,CFHighImp);
        CFImp=semiblackman(m_ls).*CFImp(1:m_ls);
end

%Convolves with loudspeaker correction
CFEqImp=postpad(fftconv(IFRImp,CFImp),m);

% Prepares final response
CFdB=mag2dB(abs(semisp(fft(CFImp))));
IFRdB=mag2dB(abs(semisp(fft(IFRImp))));
CFdB=CFdB+IFRdB;
OUTdB=CFdB+LSdB;

% Saves complete filter
savepcm(CFEqImp, [FSOutDir FSOutName '.pcm']);
audiowrite([FSOutDir FSOutName '.wav'],
            CFEqImp, GSFs, 'BitsPerSample', FSOutWavDepth);



%% plot


%newplot();
clf();
%figure(1); 
hold on;
% Generates frequencies vector
F_ls=linspace(0,mh_ls,m2_ls+1);

% define plot axis
axe=audioaxe(PSVTop,PSVRange,PSVStep,PSFLow,PSFHigh,FSOutName);

% plots original response
semilogx(F_ls,LSdB,strcat("1",";",'Original',";"));
% plots target response
semilogx(F_ls,TFRdB,strcat("2",";",'Target',";"));
% plots CF response
semilogx(F_ls,CFdB,strcat("4",";",'Filter',";"));
% plots final response
semilogx(F_ls,OUTdB,strcat("3",";",'Result',";"));

% saves plot image
print (strcat(FSOutDir,FSOutName,".png"), "-dpng");



%% log


% indicates calculation time
t2=time;
disp ("\n");
disp (strcat ('Calculated in: ' , num2str(t2-t1) , ' s'));
disp ("\n");

% save normalization factor
normfactor_dB_str=num2str(-mag2dB(normfactor));
normfile = [FSOutDir FSNormFile];
% unlink(normfile); % only once for each fs
fid=fopen(normfile, "a+t");
disp ("\n");

fputs(fid,[FSOutName, "\n"]);
fputs(fid,[normfactor_dB_str, "\n\n"]);
fclose(fid);



%% finis coronat opus
